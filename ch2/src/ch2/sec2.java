package ch2;

//변수 : 주기억장치 안에 데이터를 넣는 공간 하나로 개발자가 이름릏 부여하여 필요시 데이터를 가져갈 수 있도록 
//하기 위한 기억장소의 이름(데이터가 수시로 바뀔 수 있다는 의미에서 '변수', 변하지 않는 수는 '상수')>변수와 상수 모두 데이터를 저장하는 이름을 한다.
public class sec2 {		//sec2 클래스 이름

	public static void main(String[] args) {
		
		
		String name; 				//변수 선언(여러글자를 담을 수 있다.)시에는 ->자료형 변수명;	
		// 기본자료형(primitive) 7가지
		name = "김예은";		//변수의 초기화 -> 변수명 = 리터럴(변수명에 저장되는 값)
		int yeeun =1000000;
		char pass = 't';				//한 글자만 담을 수 있다. 그러므로 작은 따옴표로 열고닫기. 변수의 선언과 초기화
		byte data1;
		boolean data2;		//예 아니면 아니오
		short su5;
		int su1;	//정수만 담을 수 있다.
		long su2;	//소수까지
		float su3;		//소수 아래까지
		double su4;	//아주 세밀한 수
		// 문자냐 숫자냐 숫자도 실수냐 정수냐, 예 아니면 아니오냐
		// 보라색은 자바 언어에서 문법으로 정해놓은 키워드, 이 문법은 예약된 명령들은 키워드 또는 클래스 언어로 쓸 수 없다.(키워드, 예악언)
		// 영어의 대소문자를 엄격히 구분. 클래스 이름은 영문으로 저장하는 것이 원칙. 클래스 이름의 첫글자는 영어대문자로 원칙 
		//그러므로 변수명란 하나의 값을 저장할 수 있는 메모리 공간의 이름이다.
		//변수명의 명명 규착
//		- 첫 글자는 영문으로 시작하는 것이 원칙이나, 특수문자 중에서 $(달러) 또는 _(언더 스코어)로 시작할 수는 있다.
//		- 영문 대소문자는 엄격히 구분되며, 변수명은 관례상 소문자로 쓰며, 클래스 이름은 대문자로 시작한다.
//		- 자바의 예약언어는 사용할 수 없으나, 다른 문자나 숫자를 혼용하여 사용하기도 한다.
//		- 변수명이나 클래스명은 관례상 그 용도를 쉽게 알 수 있게 사용을 해야한다.
//		- 변수명이나 클래스명, 메서드명 등은 여러 단어를 연결하여 선언할 경우는 언더스코어방식과 카멜방식을 활용한다. 
		// 여러단어를 이어서 선언할 경우읽거나 판독하기 어려운->kimyeeungohome(x), 카멜방식 : kim Ye Eun Go Home(o), 언더스코어방식 : kimyeeun_go_home(o)
		//언더스코어는 어느 컴퓨터 언어든지 사용한다. 두 방식 모두다 첫번째 글자는 영어소문자.
		//예약어 : 선언자(private, public, protected, ststic, final) -> 변수명이나 그런거엔 쓸 수 없다. 사용할 경우엔 숫자랑 조합해서 가능.
//		기본 자료형 선언 키워드(char, byte, boolean, int, long, float, double)
//		참조형 선언 키워드(Char, Byte, Boolean, Int, Long, Float, Double)
//		클래스 관련 선언 키워드(class, abstract, inteface, extends, implements, enum)
//		객체 관련 키워드(new, this, super, instanceof, null)
//		명령문 키워드(if, else, switch, case, for, while, break, continue)
//		기타 키워드 : true, false, void, return, try, catch, finally, throw, throws 등
//		리터럴 : 변수에 저장되는 값, 문자, 문자열, 정수단(단,일,배) 실수(단,배), 2진수, 8진수, 16진수
		String nickname = "말랑카우";
		char nick1 = 'g';
		byte a = 120; // 컴퓨터는 이진수만 안다. 1byte=8bit=2에3승(256개) => -128 ~-1,0,1~ + 127 ->담을 수 있는 그릇이 안되어서 범위 이상의 수는 못 담는다.
		//		기억장치에 담을 수 있는 값보다 더 작은 것은 언더플로우 오류( ex= -129), 
		//		담을 수 있는 최대한의 값보다 넘필 경우엔 오버플로우(ex = 129)
		// 		저장할 수 있는 데이터의 종류가 아닌 경우의 에러 -> 타입에러
		short c = 3536; //교재38p. 2바이트
		int b = 250; // 4byte=32bit => -2,147,483,648~22,147,483,647
		long d = 450; // 8byte=64bit => 정수 부분은 다 표현 가능하다.
		//부동소수점수 = 실수
		//365.245=0.365245*10의3승(컴퓨터는 2진수)
		//부동소수점수
		//
		//부호	지수	가수(소수점 이하부분)
		//+		3승	364245
		float e = 364.245f; //4byte=>32bit , 실수로 리터럴 값을 정할 때에는 반드시 뒤에 'f'를 써줘야 실수라는 것을 인식하여 에러가 안난다.
		double f = 36.245;	//8byte=>64bit , 더블은 'f'생략이 가능
		boolean g = true;	//1bit =>1byte(표현범위가 그러하다)
		char h ='e';	//2bit
		//String i =256; 타입에러
		// 저장 크기 단위 1024byte(2의 10승) = 1KB
		//1024KB = 1MB
		//1024MB = 1GB
		//1024GB = 1TB
		//1024TB = 1PB
		//1024PB = 1EB
		
		int k1 = 0b1101;	//2진수 리터럴(0b로 시작할 경우)
		int k2 = 0123; 		//8진수 리터럴(0으로 시작할 경우)
		int k3 = 0x123;		//16진수 리터럴(0x로 시작할 경우)
		System.out.println("k1"+k1," k2"+k2, " k3"+k3);
		
		}

}
