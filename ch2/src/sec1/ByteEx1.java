package sec1;
// 한번 보고도 안되면 두번 세번 보아라. 오늘의 포인트는 원리이해하기. 강사선생님의 독학으로 이루어진 개념원리.
public class ByteEx1 {

	public static void main(String[] args) {
		// byte 타입의 변수 활용
		byte b1 = -128;
		//byte b2 = 123; 표현범위에 속하지 않음(-128~127)
		byte b3 = 0;
		//byte b4 = 0b10010110; ->127보다 크다
		//byte b5 = 0300;	>192
		//byte b6 = 0x3f4;
		byte b7 = 0b101101; //2진수
		byte b8 = 0132;	//8진수
		byte b9 = 0x3e;	//16진수
		System.out.println("b1="+b1);
		System.out.println("b3="+b3);
		System.out.println("b7="+b7);
		System.out.println("b8="+b8);
		System.out.println("b9="+b9);
		
		//진법변환!!
		//2진수 101101 -> 10진수 45=4*10+5*1, 457 => 4*10의2승+5*10의1승+7*10의0승
		//101101 => 1*2의5승+0*2의4승+1*2의3승+1*2의2승+0*2의1승+1*2의0승(~의0승=1)
		//		=> 0곱하기를 뺀 나머지 식을 곱하기
		//		=> 1*32+1*8+1*4+1*1
		//		=> 32+8+4+1
		//		=> 45
		//		다른 풀이
		//32	16	8	4	2	1
		//1		0	1	1	0	1
		//32+8+4+1
		
		//8진수
		//값: 90
		//64	8	1
		//1		3	2		<-8진수의 값
		//64+24+2 =90
		
		//16진수							**컴퓨터는 모든게 2진수
		//값: 62
		//256	16	1
		//0		3	e(=14)
		//48+14=62
		
		//거꾸로 바꿔보기
		//2진수
		//45
		//32	16		8	4	2	1 (45보다 낮은 정수로 시작, 45에서 그정수를 빼서)
		//1		0		1	1	0	1	<-2진수 값
		
		//16진수
		//값: 62
		//256	16	1
		//0		3	e		<-16진수 값 도출
		//		48	14

		//2진수->컴퓨터가 알 수 있도록하려면 기계어 코드는 2진수로 바귀어야 한다.
		//8진수(중요)-> 권한설정시에 사용되는 언어이다. 권한= 읽기(r:4)+ 쓰기(w:2)+실행권한(x:1)=7
			//	 관리자그룹과 유저들
			//		7		7		7
			//		소유자	그룹		기타
			// 예시) chmod kky.hwp 777 / 만약에 741이라면 개발자는 모든권한이 있고, 유저들은 읽기만 가능, 기타 둥다 아닌 사람은 실행만 가능.
			// 그러므로 숫자8을 넘어갈 수 없다.(4-100. 2-010, 1(001 =>2진수로 계산하면.)
			// 예)653(8진수) -> 110, 101, 011(컴퓨터가 알아듣는 2진수)
			//8진수 한자리는 2의3승임으로, 2진수의 세자리와 같다.
			// 예시) 6	5	3 ->8진수			
			//		110	101	011 ->2진수
			//		110101011 = 653
			//2진수를 8진수로 변경할땐 오른쪽에서 부터 숫자 세게씩 묶는다.
			// 예) 110 / 101 / 001
			
		//16진수-> 2진수->16진수
		//16진수는 2의4승임으로, 16진수 1자리를 2진수 4자리로 쪼갠다.
		//2진수 4자리를 오른쪽부터 한묶음으로 묶으면, 16진수의 1자리로 만들 수 있다.
			//예시)	3		e		->16진수
			//		0011 	1110  ->2진수
			
		
		//컴퓨터는 원칙적으로 뻴셈을 못함. 그래서 '보수'라는 것을 한다.
		//앞의 올림수는 날라가버림.
			//예시) 값: 64
			// 64-21=43
			// 21에 얼마를 더해야 99가 나오는가? -> 보수 (78)
			// 21 +78 = 99(9의보수)
			//64+78=142+1=143 =>43   *그러므로 64에 보수 78을 더한 값에 '+1(=10의 보수)'을 하여준다. 그후 나온 값 '143'에서 올림수는 날라감으로 맨앞자리인 1이 사라져 43의 같은 값이 나온다.
				
			
	}

}
